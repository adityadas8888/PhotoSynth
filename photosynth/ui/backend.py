from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pydantic import BaseModel
import psycopg2
import psycopg2.extras
import os
import glob

# Import your existing DB class to handle connections
from photosynth.db import PhotoSynthDB

app = FastAPI(title="PhotoSynth Face Tagger")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Paths
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
FACES_DIR = os.path.join(BASE_DIR, "faces_crop")
UI_DIR = os.path.dirname(__file__)

# Serve Face Crops (Generated by generate_thumbnails.py)
if not os.path.exists(FACES_DIR): os.makedirs(FACES_DIR)
app.mount("/faces", StaticFiles(directory=FACES_DIR), name="faces")


def get_db_cursor(conn):
    # Return a cursor that gives us dictionary results (like key:value)
    return conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)


# --- Models ---
class ClusterNameRequest(BaseModel):
    cluster_id: int
    name: str


# --- Endpoints ---

@app.get("/")
def serve_ui():
    return FileResponse(os.path.join(UI_DIR, "index.html"))


@app.get("/clusters")
def get_clusters():
    """Returns grouped faces from the Postgres DB."""
    db = PhotoSynthDB()
    conn = db.get_connection()
    try:
        cur = get_db_cursor(conn)

        # 1. Get all clusters (people)
        # Optional: Add HAVING COUNT(*) > X here to hide noise
        cur.execute("SELECT cluster_id, name FROM people ORDER BY cluster_id")
        clusters = cur.fetchall()

        result = []
        for row in clusters:
            cid = row['cluster_id']
            name = row['name']

            # 2. Get up to 10 representative files for this cluster
            faces_query = """
                SELECT f.face_id, m.file_path 
                FROM faces f 
                JOIN media_files m ON f.file_hash = m.file_hash 
                WHERE f.cluster_id = %s 
                LIMIT 10
            """
            cur.execute(faces_query, (cid,))
            face_rows = cur.fetchall()

            face_images = []
            for f_row in face_rows:
                # Look for the thumbnails generated by generate_thumbnails.py
                src_base = os.path.basename(f_row['file_path'])

                # Glob pattern to find the crop specific to this file
                pattern = os.path.join(FACES_DIR, f"{src_base}_*.jpg")
                found = glob.glob(pattern)

                if found:
                    # Take the first crop found for this file
                    filename = os.path.basename(found[0])
                    face_images.append({"id": f_row['face_id'], "url": f"/faces/{filename}"})

            # Only return clusters that actually have thumbnails generated
            if face_images:
                result.append({
                    "id": cid,
                    "name": name,
                    "faces": face_images
                })

        return result
    finally:
        conn.close()


@app.post("/tag/cluster")
def tag_cluster(req: ClusterNameRequest):
    """Updates the name or merges clusters in Postgres."""
    db = PhotoSynthDB()
    conn = db.get_connection()
    try:
        cur = conn.cursor()

        # Check if name exists elsewhere (Logic for Merge)
        cur.execute(
            "SELECT cluster_id FROM people WHERE name = %s AND cluster_id != %s",
            (req.name, req.cluster_id)
        )
        existing = cur.fetchone()

        if existing:
            # --- MERGE LOGIC ---
            target_id = existing[0]
            print(f"ðŸ”€ Merging Cluster {req.cluster_id} -> {target_id} ('{req.name}')")

            # 1. Move all faces from old cluster to new cluster
            cur.execute("UPDATE faces SET cluster_id = %s WHERE cluster_id = %s", (target_id, req.cluster_id))

            # 2. Delete the old cluster entry from 'people'
            cur.execute("DELETE FROM people WHERE cluster_id = %s", (req.cluster_id,))

            conn.commit()

            # OPTIONAL: Trigger the 'tag_media_by_cluster' task here if you want immediate metadata updates
            # from photosynth.tasks import tag_media_by_cluster
            # tag_media_by_cluster.delay(target_id, req.name)

            return {"status": "merged", "target_id": target_id}
        else:
            # --- RENAME LOGIC ---
            cur.execute("UPDATE people SET name = %s WHERE cluster_id = %s", (req.name, req.cluster_id))
            conn.commit()
            return {"status": "success"}

    except Exception as e:
        conn.rollback()
        print(f"Error tagging cluster: {e}")
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        conn.close()


@app.get("/stats")
def get_stats():
    db = PhotoSynthDB()
    conn = db.get_connection()
    cur = conn.cursor()
    try:
        cur.execute("SELECT COUNT(*) FROM media_files")
        total = cur.fetchone()[0]

        cur.execute("SELECT COUNT(*) FROM media_files WHERE status='COMPLETED'")
        processed = cur.fetchone()[0]

        cur.execute("SELECT COUNT(*) FROM faces")
        total_faces = cur.fetchone()[0]

        return {
            "total_files": total,
            "processed": processed,
            "pending": total - processed,
            "faces_found": total_faces
        }
    finally:
        conn.close()


if __name__ == "__main__":
    import uvicorn

    # Run on all interfaces so you can access it from your laptop
    uvicorn.run(app, host="0.0.0.0", port=8000)